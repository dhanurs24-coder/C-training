DYNAMIC PROGRAMMING
It is a method to solve complex problem by braking them into smaller overlapping subproblems and storing the results to avoid redundant computations.
 Two way to solve DP problems:
 1. Top Down (Memoization)(recursion + caching)
 2. Bottom Up (Tabulation)(iterative)

recursion example: Fibonacci series

 int fib(int n){
    if(n<=1) return n;
    return fib(n-1) + fib(n-2);
 }

             fib5
            /      \
        fib4      fib3
       /    \      /   \
    fib3   fib2  fib2  fib1
   /   \    / \   
 fib2 fib1 fib1 fib0
  / \
fib1 fib0
 /     /
1     0

DP example: Fibonacci series (Top Down approach)9(Memoization)
    int[] dp = new int[n+1];
    Arrays.fill(dp, -1);
    int fib(int n, int[] dp){
        if(n<=1) return n;
        if(dp[n] != -1) return dp[n];
        dp[n] = fib(n-1,dp) + fib(n-2,dp);
        return dp[n];
 }    

DP example: Fibonacci series (Bottom Up approach)(Tabulation)
    int fib(int n, int dp[]){
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }